<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>互動式三電荷電力線 (端點箭頭版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        .ui { position: absolute; top: 15px; left: 15px; color: white; background: rgba(255,255,255,0.15); padding: 15px; border-radius: 10px; pointer-events: none; font-family: sans-serif; border: 1px solid rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <div class="ui">
        <b>⚡ 物理模擬：電力線 (端點箭頭)</b><br>
        • 拖曳電荷觀察場線方向<br>
        • 箭頭指向該點的總電場方向
    </div>

<script>
let charges = [];

function setup() {
    createCanvas(windowWidth, windowHeight);
    charges.push(new Charge(width/2 - 150, height/2, 1));
    charges.push(new Charge(width/2 + 150, height/2, -1));
    charges.push(new Charge(width/2, height/2 - 150, 1));
}

function draw() {
    background(0);
    
    let density = 45; 
    for (let i = 0; i <= width; i += density) {
        for (let j = 0; j <= height; j += density) {
            drawFieldLine(i, j);
        }
    }

    for (let c of charges) {
        c.update();
        c.display();
    }
}

function drawFieldLine(x, y) {
    let px = x;
    let py = y;
    let steps = 10; 
    let stepSize = 7; 
    let currentAngle = 0;
    
    noFill();
    stroke(255, 255, 255, 70); 
    beginShape();
    
    for (let k = 0; k < steps; k++) {
        let totalE = createVector(0, 0);
        for (let c of charges) {
            let r = createVector(px - c.x, py - c.y);
            let d = r.mag();
            if (d < 15) { 
                endShape();
                return;
            }
            r.normalize().mult(c.q / (d * d) * 5000); 
            totalE.add(r);
        }
        
        currentAngle = totalE.heading();
        vertex(px, py);
        
        totalE.normalize().mult(stepSize);
        px += totalE.x;
        py += totalE.y;
    }
    endShape();

    // 在最終位置畫上箭頭
    drawArrowHead(px, py, currentAngle);
}

function drawArrowHead(x, y, angle) {
    push();
    translate(x, y);
    rotate(angle);
    fill(255, 255, 255, 200);
    noStroke();
    let sz = 5; // 箭頭大小
    // 繪製一個精緻的三角形箭頭
    triangle(sz*1.5, 0, -sz, -sz, -sz, sz);
    pop();
}

class Charge {
    constructor(x, y, q) {
        this.x = x;
        this.y = y;
        this.q = q;
        this.isDragging = false;
    }
    update() {
        if (mouseIsPressed) {
            if (dist(mouseX, mouseY, this.x, this.y) < 30 || this.isDragging) {
                this.x = mouseX;
                this.y = mouseY;
                this.isDragging = true;
            }
        } else {
            this.isDragging = false;
        }
    }
    display() {
        noStroke();
        if (this.q > 0) {
            fill(255, 71, 87); // 亮紅
        } else {
            fill(47, 53, 66); // 深灰藍
        }
        circle(this.x, this.y, 30);
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(16);
        text(this.q > 0 ? "+" : "-", this.x, this.y);
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
