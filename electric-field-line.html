<!DOCTYPE html>
<html>
<head>
    <title>互動式三電荷電力線</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        .ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="ui">
        <b>互動電力線模擬</b><br>
        拖曳電荷移動位置<br>
        紅：正電荷 | 藍：負電荷
    </div>
<script>
let charges = [];

function setup() {
  createCanvas(600, 600);
  // 模擬課本：左邊 -q/2 (編號0), 右邊 +2q (編號1)
  charges.push(new Charge(150, 300, -0.5, 4)); // 4條配額
  charges.push(new Charge(400, 300, 2, 16));   // 16條配額
}

function draw() {
  background(255);

  // 每次重畫前重設「已接收數量」
  for (let c of charges) c.connectedCount = 0;

  // 1. 先讓正電荷發射 (依照編號順序)
  for (let c of charges) {
    if (c.q > 0) {
      for (let i = 0; i < c.maxLines; i++) {
        let a = map(i, 0, c.maxLines, 0, TWO_PI);
        let startX = c.x + cos(a) * 15;
        let startY = c.y + sin(a) * 15;
        
        // 追蹤並找出終點是哪個電荷
        let target = traceAndDraw(startX, startY, 1); 
        if (target) target.connectedCount++;
      }
    }
  }

  // 2. 檢查負電荷是否還有「未填滿」的配額 (來自無窮遠的線)
  for (let c of charges) {
    if (c.q < 0) {
      let remaining = c.maxLines - c.connectedCount;
      for (let i = 0; i < remaining; i++) {
        // 在剩餘的空間中均勻發射（反向追蹤）
        let a = map(i, 0, remaining, 0, TWO_PI);
        let startX = c.x + cos(a) * 15;
        let startY = c.y + sin(a) * 15;
        traceAndDraw(startX, startY, -1);
      }
    }
  }

  for (let c of charges) { c.display(); c.update(); }
}

function traceAndDraw(sx, sy, dir) {
  let px = sx, py = sy;
  beginShape();
  noFill();
  stroke(100, 150);
  
  for (let k = 0; k < 500; k++) {
    vertex(px, py);
    let E = calculateE(px, py);
    if (E.mag() < 0.01) break;

    // 檢查是否撞到「其他」電荷
    let hit = null;
    for (let c of charges) {
      if (dist(px, py, c.x, c.y) < 15 && k > 5) { hit = c; break; }
    }
    
    if (hit) {
      endShape();
      drawArrowOnLine(px, py, E.heading(), dir); // 確保箭頭物理正確
      return hit; 
    }

    let step = E.normalize().mult(4 * dir);
    px += step.x; py += step.y;

    if (px < -50 || px > width+50 || py < -50 || py > height+50) break;
  }
  endShape();
  return null;
}
</script>
</body>
</html>


















