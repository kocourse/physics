<!DOCTYPE html>
<html>
<head>
    <title>互動式三電荷電力線</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        .ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="ui">
        <b>互動電力線模擬</b><br>
        拖曳電荷移動位置<br>
        紅：正電荷 | 藍：負電荷
    </div>
<script>
let charges = [];
const linesPerCharge = 8; 

class Charge {
    constructor(x, y, q) {
        this.x = x;
        this.y = y;
        this.q = q;
        this.isDragging = false;
    }
    update() {
        if (mouseIsPressed) {
            let d = dist(mouseX, mouseY, this.x, this.y);
            if (d < 30 || this.isDragging) {
                this.x = mouseX;
                this.y = mouseY;
                this.isDragging = true;
            }
        } else {
            this.isDragging = false;
        }
    }
    display() {
        noStroke();
        // 使用專業的紅藍漸層色
        let col = this.q > 0 ? color(200, 20, 20) : color(20, 20, 200);
        fill(col);
        circle(this.x, this.y, 35);
        
        // 畫出白色的正負號
        stroke(255);
        strokeWeight(2);
        line(this.x - 7, this.y, this.x + 7, this.y);
        if (this.q > 0) line(this.x, this.y - 7, this.x, this.y + 7);
    }
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    // 初始化配置：模擬標準偶極矩 + 一個額外正電荷
    charges.push(new Charge(width/2 - 150, height/2, 1));
    charges.push(new Charge(width/2 + 150, height/2, -1));
    charges.push(new Charge(width/2, height/2 - 200, 1));
}

function draw() {
    background(255); // 改用白色背景，與教材圖片一致
    
    for (let c of charges) {
        // 核心邏輯：正電順向發射 (1)，負電逆向接收 (-1)
        // 解決「負電荷線條太少」的問題
        let direction = (c.q > 0) ? 1 : -1;
        let numLines = Math.abs(c.q) * linesPerCharge;
        
        for (let i = 0; i < numLines; i++) {
            let a = map(i, 0, numLines, 0, TWO_PI);
            let startX = c.x + cos(a) * 20;
            let startY = c.y + sin(a) * 20;
            traceFieldLine(startX, startY, direction);
        }
    }

    for (let c of charges) {
        c.update();
        c.display();
    }
}

// 核心追蹤函數：整合了物理計算與箭頭段繪製
function traceFieldLine(startX, startY, dir) {
    let px = startX;
    let py = startY;
    let stepSize = 4;
    let maxSteps = 400; 
    let segmentInterval = 10; // 箭頭出現密度
    
    for (let k = 0; k < maxSteps; k++) {
        let totalE = createVector(0, 0);
        let stopLine = false;

        for (let c of charges) {
            let r = createVector(px - c.x, py - c.y);
            let d = r.mag();
            // 物理檢查：避免場線穿過電荷中心
            if (d < 15 && k > 2) { stopLine = true; break; }
            
            // E = kQ/r^2
            let strength = c.q / (d * d);
            r.normalize().mult(strength);
            totalE.add(r);
        }

        if (stopLine || totalE.mag() === 0) break;

        let angle = totalE.heading();
        
        // 如果是從負電荷反向追蹤，箭頭要轉 180 度指向電荷
        let arrowAngle = (dir === 1) ? angle : angle + PI;

        if (k % segmentInterval === 0) {
            drawArrowSegment(px, py, arrowAngle, 12);
        }
        
        // 根據 direction 決定前進或後退
        let v = totalE.normalize().mult(stepSize * dir);
        px += v.x;
        py += v.y;

        // 離開畫面一定距離後停止計算
        if (px < -100 || px > width + 100 || py < -100 || py > height + 100) break;
    }
}

// 修正：補上之前遺失的 drawArrowSegment 函數
function drawArrowSegment(x, y, angle, len) {
    push();
    translate(x, y);
    rotate(angle);
    stroke(100, 150); // 灰色半透明線段，視覺較細緻
    strokeWeight(1);
    line(0, 0, len, 0); 
    
    noStroke();
    fill(100, 180);
    let arrowSize = 4;
    // 在線段末端繪製小箭頭
    triangle(len + 1, 0, len - arrowSize, -arrowSize/1.5, len - arrowSize, arrowSize/1.5);
    pop();
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
















