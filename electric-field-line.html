<!DOCTYPE html>
<html>
<head>
    <title>互動式三電荷電力線</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        .ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="ui">
        <b>互動電力線模擬</b><br>
        拖曳電荷移動位置<br>
        紅：正電荷 | 藍：負電荷
    </div>
<script>
// 1. 先定義類別，確保後續 new Charge 不會報錯
class Charge {
  constructor(x, y, q, maxLines) {
    this.x = x;
    this.y = y;
    this.q = q;
    this.maxLines = maxLines; // 您定義的：該電荷應對應的電力線總數
    this.connectedCount = 0;  // 記錄已經連上的線數
    this.isDragging = false;
  }

  update() {
    if (mouseIsPressed) {
      let d = dist(mouseX, mouseY, this.x, this.y);
      if (d < 30 || this.isDragging) {
        this.x = mouseX;
        this.y = mouseY;
        this.isDragging = true;
      }
    } else {
      this.isDragging = false;
    }
  }

  display() {
    noStroke();
    fill(this.q > 0 ? '#d63031' : '#0984e3');
    circle(this.x, this.y, 35);
    stroke(255);
    strokeWeight(2);
    line(this.x - 7, this.y, this.x + 7, this.y);
    if (this.q > 0) line(this.x, this.y - 7, this.x, this.y + 7);
    
    // 顯示電量文字 (如 +2q)
    fill(0);
    noStroke();
    textSize(14);
    text(this.q + "q", this.x, this.y + 30);
  }
}

let charges = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  // 按照課本比例：+2q 對應 16 條線，-0.5q 對應 4 條線
  charges.push(new Charge(width / 2 + 100, height / 2, 2, 16));
  charges.push(new Charge(width / 2 - 200, height / 2, -0.5, 4));
}

function draw() {
  background(255);

  // 每次繪圖前，清空所有電荷的連接計數
  for (let c of charges) c.connectedCount = 0;

  // 您的編號檢查邏輯：
  // 第一步：先讓正電荷發射 (順向)
  for (let c of charges) {
    if (c.q > 0) {
      for (let i = 0; i < c.maxLines; i++) {
        let a = map(i, 0, c.maxLines, 0, TWO_PI);
        let sx = c.x + cos(a) * 18;
        let sy = c.y + sin(a) * 18;
        let target = traceFieldLine(sx, sy, 1);
        if (target) target.connectedCount++; // 如果撞到負電，對方的計數+1
      }
    }
  }

  // 第二步：檢查負電荷，補足剩餘沒被連上的線 (逆向)
  for (let c of charges) {
    if (c.q < 0) {
      let remaining = c.maxLines - c.connectedCount;
      if (remaining > 0) {
        for (let i = 0; i < remaining; i++) {
          // 為了美觀，剩餘的線在負電荷周圍均勻分布
          let a = map(i, 0, remaining, 0, TWO_PI);
          let sx = c.x + cos(a) * 18;
          let sy = c.y + sin(a) * 18;
          traceFieldLine(sx, sy, -1);
        }
      }
    }
  }

  for (let c of charges) {
    c.update();
    c.display();
  }
}

function traceFieldLine(sx, sy, dir) {
  let px = sx;
  let py = sy;
  let stepSize = 4; // 每一小步的長度
  let maxSteps = 800; // 增加步數，讓線條能延伸到對面或邊界
  
  beginShape(); // 開始繪製這條線
  noFill();
  stroke(100, 150); // 課本風格的灰色細線
  strokeWeight(1.2);

  for (let k = 0; k < maxSteps; k++) {
    // 1. 將當前座標記錄為線段的一個節點
    vertex(px, py);

    let totalE = createVector(0, 0);
    let hitCharge = null;

    // 2. 計算該點受到的合電場 (向量疊加)
    for (let c of charges) {
      let r = createVector(px - c.x, py - c.y);
      let d = r.mag();
      
      // 碰撞偵測：如果撞到「非起始」電荷，就連上去並結束
      if (d < 15 && k > 5) { hitCharge = c; break; }
      
      let strength = c.q / (d * d); // E = kQ/r^2
      r.normalize().mult(strength);
      totalE.add(r);
    }

    // 3. 處理碰撞與停止條件
    if (hitCharge) {
      vertex(hitCharge.x, hitCharge.y); // 強制連到電荷中心
      endShape();
      return hitCharge; // 回傳給 draw()，告知編號補線邏輯「已接上」
    }

    if (totalE.mag() < 0.001) break; // 電場太弱就停下

    // 4. 定期畫箭頭（課本那種路徑上的小尖頭）
    if (k % 60 === 30) drawArrowHead(px, py, totalE.heading());

    // 5. 更新位置：dir 為 1 順著畫，-1 逆著畫
    let move = totalE.normalize().mult(stepSize * dir);
    px += move.x;
    py += move.y;

    // 6. 出界檢查：到了螢幕邊緣就停
    if (px < -width || px > width * 2 || py < -height || py > height * 2) break;
  }
  endShape();
  return null;
}

// 課本風格的小箭頭
function drawArrowHead(x, y, angle) {
  push();
  translate(x, y);
  rotate(angle);
  fill(100); noStroke();
  triangle(0, 0, -7, -3.5, -7, 3.5);
  pop();
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>





















