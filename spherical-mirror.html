<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>球面鏡成像互動模擬 - Spherical Mirror</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background: #f4f4f4; }
        .controls { display: flex; gap: 15px; margin-bottom: 15px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; }
        label { font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #333; }
        input { width: 150px; padding: 5px; }
        canvas { border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .info { margin-top: 10px; color: #666; font-size: 14px; }
    </style>
</head>
<body>

    <h2>球面鏡成像互動模擬</h2>
    
    <div class="controls">
        <div class="input-group">
            <label>物距 p: <span id="val_p">60</span> cm</label>
            <input type="range" id="input_p" min="5" max="250" value="60" step="1">
        </div>
        <div class="input-group">
            <label>焦距 f: <span id="val_f">40</span> cm (正值凹，負值凸)</label>
            <input type="range" id="input_f" min="-100" max="100" value="40" step="1">
        </div>
    </div>

    <div id="canvas-container"></div>
    <div class="info">※ 綠色為物體 (O)，紅色為像 (I)，橘色為焦點 (F)，黑色為曲率中心 (C)。</div>

<script>
let p, f;
let offsetX = 500; 
let scaleFactor = 2;

function setup() {
    let canvas = createCanvas(800, 400);
    canvas.parent('canvas-container');
    select('#input_p').input(updateParams);
    select('#input_f').input(updateParams);
    updateParams();
    noLoop();
}

function updateParams() {
    p = parseFloat(select('#input_p').value());
    f = parseFloat(select('#input_f').value());
    if (f === 0) f = 0.1; 
    select('#val_p').html(p);
    select('#val_f').html(f);
    redraw();
}

function draw() {
    background(255);
    translate(offsetX, height / 2);

    // 1. 畫主光軸
    stroke(220);
    strokeWeight(1);
    line(-offsetX, 0, width - offsetX, 0);

    // 2. 畫球面鏡 (弧線與背影)
    let r_px = Math.abs(2 * f * scaleFactor); // 曲率半徑
    let h_limit = 150; // 鏡子高度
    let x_offset = 0;

    noFill();
    stroke(100);
    strokeWeight(4);
    
    // 根據 f 的正負決定弧向
    if (f > 0) { // 凹面鏡 (鏡面朝左)
        let angle = asin(h_limit / r_px);
        arc(r_px, 0, r_px * 2, r_px * 2, PI - angle, PI + angle);
        // 畫背影斜線
        strokeWeight(1);
        for(let i = -h_limit; i <= h_limit; i += 10) {
            let x = r_px - sqrt(r_px**2 - i**2);
            line(x, i, x + 5, i - 5);
        }
    } else { // 凸面鏡 (鏡面朝左)
        let angle = asin(h_limit / r_px);
        arc(-r_px, 0, r_px * 2, r_px * 2, -angle, angle);
        // 畫背影斜線
        strokeWeight(1);
        for(let i = -h_limit; i <= h_limit; i += 10) {
            let x = -r_px + sqrt(r_px**2 - i**2);
            line(x, i, x - 5, i - 5);
        }
    }

    // 3. 物理計算
    let q = 1 / ((1/f) - (1/p));
    let mag = -q / p;
    let p_px = -p * scaleFactor;
    let q_px = -q * scaleFactor; // 在鏡前為實像(負座標)，鏡後為虛像(正座標)
    let f_px = -f * scaleFactor;
    let c_px = -2 * f * scaleFactor;

    // 4. 關鍵點標記
    fill(255, 140, 0); noStroke(); ellipse(f_px, 0, 8, 8); text('F', f_px - 5, 20);
    fill(0); ellipse(c_px, 0, 8, 8); text('C', c_px - 5, 20);

    // 5. 物體與像
    stroke(0, 128, 0); strokeWeight(3);
    line(p_px, 0, p_px, -50); 
    fill(0, 128, 0); noStroke(); text('O', p_px - 5, -60);

    if (isFinite(q_px)) {
        stroke(255, 0, 0); strokeWeight(3);
        line(q_px, 0, q_px, -50 * mag);
        fill(255, 0, 0); noStroke(); 
        text(q > 0 ? 'I (Real)' : 'I (Virtual)', q_px - 20, -50 * mag - 10);
    }

// 6. 模擬反射光線 (修正物理邏輯)
    strokeWeight(1);
    
    // (1) 平行主軸光線 -> 反射後「折返」過 F
    stroke(100, 100, 255, 200);
    line(p_px, -50, 0, -50); // 入射光 (向右)
    
    if (q > 0) {
        // 實像：反射光真正經過 q_px
        line(0, -50, q_px, -50 * mag); 
    } else {
        // 虛像：反射光向左發散，右側為虛線延長線
        let endX = -offsetX; // 往左邊畫到畫布邊緣
        let slope = (-50 * mag - (-50)) / (q_px - 0);
        line(0, -50, endX, -50 + slope * (endX - 0)); // 向左的反射光
        
        drawingContext.setLineDash([5, 5]);
        line(0, -50, q_px, -50 * mag); // 向右的虛像延長線
        drawingContext.setLineDash([]);
    }

    // (2) 過頂點光線 -> 入射角 = 反射角 (向左折返)
    stroke(150, 150, 0, 200);
    line(p_px, -50, 0, 0); // 入射光 (向右下)
    
    if (q > 0) {
        line(0, 0, q_px, -50 * mag); // 反射光 (向左下過實像)
    } else {
        let endX = -offsetX;
        let slope = (-50 * mag - 0) / (q_px - 0);
        line(0, 0, endX, slope * endX); // 向左下發散
        
        drawingContext.setLineDash([5, 5]);
        line(0, 0, q_px, -50 * mag); // 向右上延伸至虛像
        drawingContext.setLineDash([]);
    }

    // 7. 顯示數據
    resetMatrix();
    fill(0); noStroke(); textSize(14);
    text(`物距 p: ${p.toFixed(1)} cm`, 20, 40);
    text(`像距 q: ${q.toFixed(1)} cm`, 20, 60);
    text(`類型: ${q > 0 ? "實像 (鏡前)" : "虛像 (鏡後)"}`, 20, 80);
}
</script>
</body>
</html>

