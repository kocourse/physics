<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>球面鏡成像互動模擬 - Mirror Equation</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background: #f4f4f4; }
        .controls { display: flex; gap: 15px; margin-bottom: 15px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex-wrap: wrap; }
        .input-group { display: flex; flex-direction: column; }
        label { font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #333; }
        input { width: 150px; padding: 5px; }
        canvas { border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .info { margin-top: 10px; color: #666; font-size: 14px; }
    </style>
</head>
<body>

    <h2>球面鏡成像互動模擬</h2>
    
    <div class="controls">
        <div class="input-group">
            <label>物距 p: <span id="val_p">60</span> cm</label>
            <input type="range" id="input_p" min="5" max="200" value="60" step="1">
        </div>
        <div class="input-group">
            <label>焦距 f: <span id="val_f">40</span> cm (正值為凹面鏡，負值為凸面鏡)</label>
            <input type="range" id="input_f" min="-100" max="100" value="40" step="1">
        </div>
    </div>

    <div id="canvas-container"></div>
    <div class="info">※ 綠色為物體 (O)，紅色為像 (I)，橘色為焦點 (F)，黑色為曲率中心 (C)。</div>

<script>
let p, f;
let offsetX = 600; // 鏡面位置靠右，因為大部分光路在左側
let scaleFactor = 2.5;

function setup() {
    let canvas = createCanvas(800, 400);
    canvas.parent('canvas-container');
    select('#input_p').input(updateParams);
    select('#input_f').input(updateParams);
    updateParams();
    noLoop();
}

function updateParams() {
    p = parseFloat(select('#input_p').value());
    f = parseFloat(select('#input_f').value());
    if (f === 0) f = 0.1; // 避免焦距為 0
    select('#val_p').html(p);
    select('#val_f').html(f);
    redraw();
}

function draw() {
    background(255);
    translate(offsetX, height / 2);

    let r_px = 2 * f * scaleFactor; 
    let p_px = -p * scaleFactor;
    let q = 1 / ((1/f) - (1/p));
    let q_px = -q * scaleFactor;
    let mag = -q / p;
    let f_px = -f * scaleFactor;
    let c_px = -2 * f * scaleFactor;

    // 1. 畫主光軸
    stroke(220); line(-offsetX, 0, width - offsetX, 0);
/*
    // 2. 畫球面鏡 (圓弧)
    noFill(); stroke(100); strokeWeight(3);
    let h_limit = 120;
    let absR = Math.abs(r_px);
    let angle = asin(min(1, h_limit / absR));
    
    if (f > 0) { // 凹面鏡
        arc(c_px, 0, absR * 2, absR * 2, -angle, angle);
    } else { // 凸面鏡
        arc(c_px, 0, absR * 2, absR * 2, PI - angle, PI + angle);
    }
*/
// --- 2. 畫球面鏡 (圓弧與背面斜線) ---
    noFill(); 
    stroke(100); 
    strokeWeight(3);
    
    let absR = Math.abs(2 * f * scaleFactor); 
    let h_limit = 120; // 鏡面半高度
    // 關鍵修正：確保 asin 的參數在 -1 到 1 之間，避免產生 NaN
    let angleLimit = asin(min(0.99, h_limit / absR)); 
    
    // A. 畫主圓弧 (實線)
    if (f > 0) {
        // 凹面鏡：圓心在左側 c_px
        arc(c_px, 0, absR * 2, absR * 2, -angleLimit, angleLimit);
    } else {
        // 凸面鏡：圓心在右側 c_px
        arc(c_px, 0, absR * 2, absR * 2, PI - angleLimit, PI + angleLimit);
    }

    // B. 畫背面斜線
    strokeWeight(1);
    // 設定虛線樣式 (實線 2px, 空白 2px)
    drawingContext.setLineDash([2, 2]); 

    for (let a = -angleLimit; a <= angleLimit; a += 0.15) {
        let startX, startY;
        if (f > 0) {
            // 凹面鏡：背面在圓弧右側
            startX = c_px + absR * cos(a);
            startY = absR * sin(a);
            line(startX, startY, startX + 8, startY - 8); // 向右上方延伸
        } else {
            // 凸面鏡：背面在圓弧左側 (圓心側)
            startX = c_px + absR * cos(PI + a);
            startY = absR * sin(PI + a);
            line(startX, startY, startX - 8, startY - 8); // 向左上方延伸
        }
    }

    // *** 重要：畫完後立刻重置為實線模式，否則所有東西都會變虛線 ***
    drawingContext.setLineDash([]);

    
    // 3. 標記 F 與 C
    fill(255, 140, 0); noStroke(); ellipse(f_px, 0, 8, 8); text('F', f_px - 5, 20);
    fill(0); ellipse(c_px, 0, 8, 8); text('C', c_px - 5, 20);

    // 4. 物體與像
    stroke(0, 128, 0); strokeWeight(3);
    line(p_px, 0, p_px, -50); 
    fill(0, 128, 0); noStroke(); text('O', p_px - 5, -60);

    if (isFinite(q_px)) {
        stroke(255, 0, 0); strokeWeight(3);
        line(q_px, 0, q_px, -50 * mag);
        fill(255, 0, 0); noStroke(); 
        text(q > 0 ? 'I (Real)' : 'I (Virtual)', q_px - 20, -50 * mag - 10);
    }

    // 5. 特殊光線 (統一由物體頂端發出)
    let h_obj = -50; // 物體高度固定為 -50
    let h_ray = -50; // 平行光的高度也設為 -50
    
    // 計算平行光的圓弧反射點 x_hit
    let x_hit = (f > 0) ? (c_px + sqrt(max(0, absR**2 - h_ray**2))) : (c_px - sqrt(max(0, absR**2 - h_ray**2)));

    strokeWeight(1);
    
    // --- (1) 平行主軸光線 ---
    stroke(100, 100, 255, 200);
    line(p_px, h_obj, x_hit, h_ray); // 入射：從物體頂端出發

    if (q > 0) {
        line(x_hit, h_ray, q_px, -50 * mag); // 反射：經過像的頂端
    } else {
        // 虛像邏輯... (維持不變，但確保座標連向 q_px)
        let reflect_slope = (-50 * mag - h_ray) / (q_px - x_hit);
        line(x_hit, h_ray, -offsetX, h_ray + reflect_slope * (-offsetX - x_hit));
        drawingContext.setLineDash([5, 5]);
        line(x_hit, h_ray, q_px, -50 * mag);
        drawingContext.setLineDash([]);
    }

    // --- (2) 過頂點 (0,0) 的光線 ---
    stroke(150, 150, 0, 200);
    line(p_px, h_obj, 0, 0); // 入射：從物體頂端射向鏡面頂點 (0,0)
    
    if (q > 0) {
        line(0, 0, q_px, -50 * mag); // 反射：依據反射定律經過像的頂端
    } else {
        // 虛像邏輯... (連向右側虛像頂端)
        let v_slope = (-50 * mag - 0) / (q_px - 0);
        line(0, 0, -offsetX, v_slope * -offsetX);
        drawingContext.setLineDash([5, 5]);
        line(0, 0, q_px, -50 * mag);
        drawingContext.setLineDash([]);
    }

    // 6. 數據顯示
    resetMatrix();
    fill(0); noStroke();
    text(`計算像距 q: ${q.toFixed(1)} cm`, 20, 40);
    text(`類型: ${q > 0 ? "實像 (Real)" : "虛像 (Virtual)"}`, 20, 60);
}
</script>
</body>

</html>






